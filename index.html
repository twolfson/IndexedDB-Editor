<!doctype>
<html>
<head>
	<title>MDN Derby - December 2011</title>
	<style>
    /* Visual fixes (poor man's reset/normalize.css) */
		* {
			margin: 0;
			padding: 0;
		}

    body {
      background: linen;
    }

    body > div {
      margin-bottom: 1em;
    }

    .labelField {
      display: inline;
    }

    .error {
      color: red;
      font-weight: bold;
    }

    #tableContainer {
      display: inline;
    }

    #table {
      border-collapse: collapse;
      display: inline;
    }

    #table th {
      background: #E9E9E9;
      padding: 20px;
      border: 2px solid #CCC;
    }

    #table td {
      border: 2px solid #CCC;
      background: #FFF;
      cursor: text;
    }

    #table td.disabled {
      background: inherit;
      cursor: inherit;
    }

    #table input {
      border: 0;
      padding: 1em;
    }

    #table td.disabled input {
      visibility: hidden;
    }

    #addCol {
      vertical-align: top;
    }

    #console {
      background: #CCC;
      height: 20em;
      overflow: auto;
    }
	</style>
</head>
<body>
<h1>IndexedDB Demonstration</h1>
<div>
  <p>
    In this demonstration, a sample database has been set up, via the IndexedDB API, as well as an example table. There is an interface to create more tables on the fly and edit the table fields at will.
    <br/>
    The purpose of this demonstration is to show that IndexedDB can be tapered down to represent any 'tame' store as a table.
  </p>
</div>
<div>
  <div class="labelField">
    <label for="database">Database: </label><input id="database" name="database" type="text" value="devDerby" disabled="disabled" /> <button id="changeDatabase">Change</button>
  </div>
  &nbsp;&nbsp;&nbsp;&nbsp;
  <div class="labelField">
    <label for="tableSelect">Table: </label><select id="tableSelect" name="tableSelect" disabled="disabled"></select> <button id="createTable">Create Table</button>
  </div>
</div>
<div>
  <div id="tableContainer">
    <table id="table">
    </table>
  </div>
  <button id="addCol">Add Column</button>
</div>
<div>
  <button id="addRow">Add Row</button>
</div>
<div id="jsonView">
</div>
<div>
  <h2>Console:</h2>
  <div id="console">
  </div>
</div>
<!--
  Neat but not sure if I will do:
    - Add ability for formula row
      -> Add this.row, this.col, this.get(row, col), this.getRel(relRow, relCol)
    - Add multi-row editing
    - Column/row resizing

  TODO:
    - Update table select box
    - Implement create table button
    - Implement db selection
    - Down coerce JSON to string and try to upconvert JSON to object
    - JSON view
    - Load from CSV and JSON
    - Handle basic string case
-->
<script>
(function(window, document){
  // Fallback and globalize indexedDB variables
  window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB;
  window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
  window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
  window.IDBCursor = window.IDBCursor || window.webkitIDBCursor;

  // Localize indexedDB
  var indexedDB = window.indexedDB,
      _database = document.getElementById('database'),
      _changeDatabase = document.getElementById('changeDatabase'),
      _tableSelect = document.getElementById('tableSelect'),
      _createTable = document.getElementById('createTable'),
      _consoleDiv = document.getElementById('console'),
      _console = {
        'error': function (msg) {
          this.log('<span class="error">' + msg + '</span>');
        },
        'log': function (msg) {
          _consoleDiv.innerHTML = '<div>[' + (new Date().toLocaleString()) + '] ' + msg + '</div>' + _consoleDiv.innerHTML;
        }
      };

  // If indexedDB cannot be found
  if (indexedDB === undefined) {
    // Let the user know a different browser should be used
    _console.error('Your browser does not support IndexedDB');
    return;
  }

  function noop() {
  }

  function Indexer() {
    this.clear();
  }
  Indexer.prototype = {
    'push': function (key) {
      var map = this.map;
      if (map.hasOwnProperty(key)) {
        _console.error('Key is already defined: ' + key);
        throw new Error('Indexer key is already defined: ' + key);
      }
      // Save key to counter value (preserves order even through decrement)
      map[key] = this.counter;

      // Add item to array
      this.arr.push(key);

      // Increment counter
      this.counter += 1;
    },
    'delete': function (key) {
      // Delete from map
      delete this.map[key];

      // Find and remove item from array
      var arr = this.arr,
          arrIndex = arr.indexOf(key);
      arr.splice(arrIndex, 1);
    },
    'count': function () {
      return this.arr.length;
    },
    'clear': function () {
      this.arr = [];
      this.map = {};
      this.counter = 0;
    }
  };

  // Objectify table
  var table = (function(document){
    var retObj = {},
    // Localize and privitize the table
        _table = document.getElementById('table'),
        _tableParent = _table.parentNode,
        _tableHeader = document.createElement('tr');
    _tableHeader.appendChild( document.createElement('th') );
    _table.appendChild(_tableHeader);

    // Private vars
        _rows = [],
        _rowIndexer = new Indexer(),
        _colIndexer = new Indexer();

    // Private helper fns
    function _actOnEachRow(fn) {
      var row,
          i;
      for (i = _rows.length; i--; ) {
        row = _rows[i];
        fn(i, row);
      }
    }

    function _createCell(rowKey, colKey, val) {
      // Visciously require a row and column number during construction
      if (rowKey === undefined || colKey === undefined) {
        throw new Error('Row/col not specified for cell constructor');
      }

      var td = document.createElement('td'),
          input = document.createElement('input'),
          _lastVal = val || '',
          checkTimeout;

      // Set up input type and value
      input.setAttribute('type', 'text');
      input.value = _lastVal;

      // If the the value is undefined, disable the cell
      if (val === undefined) {
        td.className = 'disabled';
      }

      // Watch content for changes
      function checkChange() {
        var val = input.value;
        if (_lastVal !== val) {
          _lastVal = val;
          retObj.oncellupdate(rowKey, colKey, val);
        }
      }

      function checkChangeLoop() {
        // Memoize timeout for onblur
        checkTimeout = setTimeout(function () {
          // Check if anything has changed
          checkChange();

          // Loop on self
          checkChangeLoop();
        }, 100);
      }

      input.onfocus = checkChangeLoop;

      input.onblur = function () {
        // Stop any further checks
        clearTimeout(checkTimeout);

        // Perform one final check
        checkChange();
      };

      // Append the input to the td
      td.appendChild(input);

      // On a single click of the td, focus to the input
      td.onclick = function () {
        // Only if the td is enabled
        var className = td.className;
        if (className === undefined || className === '') {
          input.focus();
        }
      }

      // On a double click of the td, enable/disable the cell
      td.ondblclick = function () {
        var className = td.className;

        // If the element is currently enabled
        if (className === undefined || className === '') {
          // Disable it
          td.className = 'disabled';

          // And announce that it has been disabled
          retObj.oncelldisable(rowKey, colKey, val);
        } else {
        // Otherwise,  enable it
          td.className = '';

          // And announce that it has been enabled
          retObj.oncellenable(rowKey, colKey, val);
        }
      };

      // Return generated cell
      return td;
    }

    retObj = {
      'removeFromFlow': function () {
        _tableParent.removeChild(_table);
        _table.setAttribute('style', 'display: none');

        // Set this to a noop
        var that = this,
            _removeFromFlow = this.removeFromFlow,
            _returnToFlow = this.returnToFlow;
        this.removeFromFlow = noop;

        // And make returnToFlow rebind self
        this.returnToFlow = function () {
          // Invoke intended function
          _returnToFlow.apply(that);

          // Return removeFromFlow and returnToReflow to normal
          that.removeFromFlow = _removeFromFlow;
          that.returnToFlow = _returnToFlow;
        };
      },
      'returnToFlow': function () {
        _table.setAttribute('style', '');
        _tableParent.appendChild(_table);
      },
      'flushTable': function () {
        // Localize key arrays
        var colKeys = _colIndexer.arr,
            rowKeys = _rowIndexer.arr,
            i;

        // Delete all rows
        for (i = rowKeys.length; i--; ) {
          this.deleteRow(rowKeys[i], true);
        }

        // Delete all columns
        for (i = colKeys.length; i--; ) {
          this.deleteCol(colKeys[i], true);
        }

        // Clear out indexers
        _colIndexer.clear();
        _rowIndexer.clear();
      },
      'deleteRow': function (rowKey, silentDelete) {
        // Grab the current array of rows
        var rowKeys = _rowIndexer.arr,
            index = rowKeys.indexOf(rowKey),
            row = _rows[index];

        // Remove the row from the table
        _table.removeChild(row);

        // Remove the row from the rows array
        _rows.splice(index, 1);

        // Remove the key from the indexer
        _rowIndexer['delete'](rowKey);

        // Announce event
        if (silentDelete !== true) {
          this.onrowdelete(rowKey);
        }
      },
      'deleteCol': function (colKey, silentDelete) {
        // Take out of the DOM for reduction of reflows
        this.removeFromFlow();

        // Grab the current array of rows
        var colKeys = _colIndexer.arr,
            index = colKeys.indexOf(colKey),
            cellIndex = index + 1;

        // Remove header row's cell
        _tableHeader.removeChild( _tableHeader.childNodes[cellIndex] );

        // Remove the column's cell from each row
        _actOnEachRow(function (i, row) {
          row.removeChild( row.childNodes[cellIndex] );
        });

        // Remove the key from the indexer
        _colIndexer['delete'](colKey);

        // Shove back in the DOM
        this.returnToFlow();

        // Announce event
        if (silentDelete !== true) {
          this.oncoldelete(colKey);
        }
      },
      'addRow': function (rowKey, row, silentAdd) {
        // Save new row key (and check to make sure we are not double-adding object keys)
        _rowIndexer.push(rowKey);

        var that = this,
            tr = document.createElement('tr'),
            th = document.createElement('th'),
            deleteButton = document.createElement('button'),
            colKeys = _colIndexer.map,
            key;

        // Set up bindings for delete button
        deleteButton.innerHTML = 'Delete row';
        deleteButton.onclick = function () {
          that.deleteRow(rowKey);
        };

        // Generate th for the row
        th.innerHTML = rowKey + '<br/>';
        th.appendChild(deleteButton);
        tr.appendChild(th);

        // Iterate the keys and generate any new columns
        for (key in row) {
          if (row.hasOwnProperty(key)) {
            if (!colKeys.hasOwnProperty(key)) {
              this.addCol(key);
            }
          }
        }

        // Iterate the table's columns
        var colNameArr = _colIndexer.arr,
            colName,
            j = 0,
            len = colNameArr.length,
            td;

        for ( ; j < len; j++ ) {
          // Localize column name
          colName = colNameArr[j];

          // Populate the cell
          td = _createCell(rowKey, colName, row[colName]);

           // Append the cell to the row
          tr.appendChild(td);
        }

        // Append row to table
        _table.appendChild(tr);

        // Increment rowCount and save to rows
        _rows.push(tr);

        // Announce addition
        if (silentAdd !== true) {
          this.onrowadd(rowKey, row);
        }
      },
      'addCol': function (colKey, silentAdd) {
        // Index latest key
        _colIndexer.push(colKey);

        var that = this,
            th = document.createElement('th'),
            deleteButton = document.createElement('button');

        // Set up bindings for delete button
        deleteButton.innerHTML = 'Delete column';
        deleteButton.onclick = function () {
          that.deleteCol(colKey);
        };

        // Add th
        th.innerHTML = colKey + '<br/>';
        th.appendChild(deleteButton);
        _tableHeader.appendChild(th);

        // Add new cell for each row
        var rowKeys = _rowIndexer.arr;
        _actOnEachRow(function (i, row) {
          var rowKey = rowKeys[i];
          row.appendChild( _createCell(rowKey, colKey) );
        });

        // Announce addition
        if (silentAdd !== true) {
          this.oncoladd(colKey);
        }
      },
      'populate': function (rows) {
        var key;

        // Hide the table and remove it from the DOM (reduce repaints/reflows)
        this.removeFromFlow();

        // Clean out the table
        this.flushTable();

        // Iterate object and add rows
        for (key in rows) {
          if (rows.hasOwnProperty(key)) {
            this.addRow(key, rows[key], true);
          }
        }

        // Unhide the table
        this.returnToFlow();
      },
      // Cell methods
      'oncellenable': noop,
      'oncelldisable': noop,
      'oncellupdate': noop,

      // Row methods
      'onrowadd': noop,
      'onrowdelete': noop,

      // Column methods
      'oncoladd': noop,
      'oncoldelete': noop
    };

    // Listen to addRow and addColumn and trigger appropriate functions
    var addRowButton = document.getElementById('addRow'),
        addColButton = document.getElementById('addCol');

    addRowButton.onclick = function () {
      var rowName = prompt('What would you like to title the new row?');
      retObj.addRow(rowName, {});
    };

    addColButton.onclick = function () {
      var colName = prompt('What would you like to title the new column?');
      retObj.addCol(colName);
    };

    return retObj;
  }(document));

  function onchangedb() {
    // Attempt to open our db
    var databaseName = _database.value || 'devDerby',
        derbyDbRequest = indexedDB.open(databaseName);

    // If we are denied
    derbyDbRequest.onerror = function () {
      // Let the user know we need access to continue
      _console.error('You must allow access to your IndexedDB for this webpage');
      return;
    };

    // If we are allowed in
    derbyDbRequest.onsuccess = function (e) {
      // Grab the db
      var derbyDb = e.target.result;

      // Set up error handling
      function onerror(f) {
        _console.error('An error has occurred that I have not accounted for. Please panic or refresh the page');
        console && console.error && console.error(f);
        return;
      }
      derbyDb.onerror = onerror;

      // And disco.

      // Set up continue fn
      function continueFn() {
        var objectStoreNames = derbyDb.objectStoreNames,
            objectStoreName,
            i = 0,
            len = objectStoreNames.length,
            option,
            rows = {},
            transaction,
            objectStore,
            cursor;

        if (len < 1) {
          onerror('No object stores exist when one should');
        }

        // Populate the select box with store names
        for ( ; i < len; i++ ) {
          option = document.createElement('option');
          option.innerHTML = objectStoreNames[i];
          _tableSelect.appendChild(option);
          // TODO: Clear tableSelect on DB change
        }

        // Choose the first alphabetical table from objectStoreNames
        objectStoreName = objectStoreNames[0];

        // Then begin to collect rows
        transaction = derbyDb.transaction(objectStoreName);
        objectStore = transaction.objectStore(objectStoreName);
        cursorRequest = objectStore.openCursor();

        // Handle errors and successes
        cursorRequest.onerror = onerror;
        cursorRequest.onsuccess = function () {
          var cursor = cursorRequest.result,
              getRequest,
              updateDb;

          // If the cursor is pointing to something
          if (cursor !== undefined) {
            // Retrieve it
            getRequest = objectStore.get(cursor.key);
            getRequest.onerror = onerror;
            getRequest.onsuccess = function () {
              // And add it to a new row
              rows[cursor.key] = getRequest.result;

              // Continue to next row
              cursor.continue();
            };
          } else {
          // Otherwise, populate the table
            table.populate(rows);

            updateDb = function (value, key, successFn) {
              var transaction = derbyDb.transaction(objectStoreName, IDBTransaction.READ_WRITE),
                  objectStore = transaction.objectStore(objectStoreName),
                  request = objectStore.put(value, key);
              request.onerror = onerror;
              request.onsuccess = successFn;
            };

            // And update to the proper oncellupdate
            table.oncellupdate = function (rowKey, colKey, value) {
              // Update our local copy of row
              var row = rows[rowKey];
              row[colKey] = value;

              // Try to save to db
              updateDb(row, rowKey, function () {
                _console.log('Row &quot;' + rowKey + '&quot;, Column &quot;' + colKey + '&quot; successfully updated.');
              });
            };

            // Update on a cell enable
            table.oncellenable = function (rowKey, colKey, value) {
              // Update our local copy of row
              var row = rows[rowKey];
              row[colKey] = value || '';

              // Try to save to db
              updateDb(row, rowKey, function () {
                _console.log('Row &quot;' + rowKey + '&quot;, Column &quot;' + colKey + '&quot; successfully enabled.');
              });
            };

            // Update on a cell disable
            table.oncelldisable = function (rowKey, colKey, value) {
              // Update our local copy of row
              var row = rows[rowKey];
              delete row[colKey];

              // Try to save to db
              updateDb(row, rowKey, function () {
                _console.log('Row &quot;' + rowKey + '&quot;, Column &quot;' + colKey + '&quot; successfully disabled.');
              });
            };

            // Update on row creation
            table.onrowadd = function (rowKey, row) {
              // Update our local copy of row
              rows[rowKey] = row;

              // Try to save to db
              updateDb(row, rowKey, function () {
                _console.log('Row &quot;' + rowKey + '&quot; successfully added.');
              });
            };

            // Update on row deletion
            table.onrowdelete = function (rowKey) {
              // Update our local copy of row
              delete rows[rowKey];

              // Try to save to db
              var transaction = derbyDb.transaction(objectStoreName, IDBTransaction.READ_WRITE),
                  objectStore = transaction.objectStore(objectStoreName),
                  request = objectStore.delete(rowKey);
              request.onerror = onerror;
              request.onsuccess = function () {
                _console.log('Row &quot;' + rowKey + '&quot; successfully deleted.');
              };
            };

            // Update on column creation
            table.oncoladd = function (colKey) {
              _console.log('Column &quot;' + colKey + '&quot; successfully added.');
            };

            // Update on column deletion
            table.oncoldelete = function (colKey) {
              // Open a transaction since this is a multi-item edit
              var transaction = derbyDb.transaction(objectStoreName, IDBTransaction.READ_WRITE),
                  objectStore = transaction.objectStore(objectStoreName),
                  row,
                  rowKey,
                  i;

              // Iterate each row
              for (rowKey in rows) {
                if (rows.hasOwnProperty(rowKey)) {
                  row = rows[rowKey];

                  // If it has the property listed
                  if (row.hasOwnProperty(colKey)) {
                    // Delete row's entry
                    delete row[colKey];

                    // Make request to update database
                    objectStore.put(row, rowKey);
                  }
                }
              }

              transaction.onerror = onerror;
              transaction.oncomplete = function () {
                _console.log('Column &quot;' + colKey + '&quot; successfully deleted.');
              };
            };
          }
        }
      }

      // Helper function for creating sheets
      function createSheet(name, callback) {
        var req = derbyDb.setVersion('0.1');
        req.onerror = onerror;
        req.onsuccess = function () {
          var newStore = derbyDb.createObjectStore(name),
              // ''     'Hello' 'and'       'welcome'       'to'
              // 'my'   'MDN'   'Dev Derby' 'demonstration' -
              // 'of'   -       -           -               'IndexedDB'
              rowObjs = {
                'my': {
                  'Hello': 'MDN',
                  'and': 'Dev Derby',
                  'welcome': 'demonstration'
                },
                'of': {
                  'to': 'IndexedDB'
                }
              },
              key,
              rowKeyArr = [],
              i = 0,
              len;

          // Populate rowArr
          for (key in rowObjs) {
            if (rowObjs.hasOwnProperty(key)) {
              rowKeyArr.push(key);
            }
          }
          len = rowKeyArr.length;

          function addNextRow() {
            // If we have added all the rows, call our callback
            if (i >= len) {
              if (callback) {
                callback();
              }
              return;
            }

            // Add row to store
            var rowKey = rowKeyArr[i],
                putRequest = newStore.put(rowObjs[rowKey], rowKey);
            putRequest.onerror = onerror;
            putRequest.onsuccess = function () {
              // Increment and continue looping
              i += 1;
              addNextRow();
            };
          }

          // Begin adding rows
          addNextRow();
        }
      }

      // If no tables are found
      if (derbyDb.objectStoreNames.length === 0) {
        // Populate our example table
        createSheet('Example Table', continueFn);
      } else {
      // Otherwise, invoke continueFn
        continueFn();
      }
    };
  }

  // Open the currently listed database
  onchangedb();

  // And watch for clicks on the change button
  _changeDatabase.onclick = onchangedb;
}(this, document));
</script>
</body>
</html>
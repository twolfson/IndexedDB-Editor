<!doctype>
<html>
<head>
	<title>MDN Derby - December 2011</title>
	<style>
    /* Visual fixes (poor man's reset/normalize.css) */
		* {
			margin: 0;
			padding: 0;
		}

    body {
      background: linen;
    }

    body > div {
      margin-bottom: 1em;
    }

    .labelField {
      display: inline;
    }

    .error {
      color: red;
      font-weight: bold;
    }

    #table {
      border-collapse: collapse;
    }

    #table th {
      background: #E9E9E9;
      padding: 20px;
      border: 2px solid #CCC;
    }

    #table td {
      border: 2px solid #CCC;
    }

    #table input {
      border: 0;
      padding: 22px; /* Same as th padding + 2px */
    }

    #table td.disabled input {
      visibility: hidden;
    }

    #console {
      background: #CCC;
      height: 20em;
      overflow: auto;
    }
	</style>
</head>
<body>
<h1>IndexedDB Demonstration</h1>
<div>
  <p>
    In this demonstration, a sample database has been set up, via the IndexedDB API, as well as an example table. There is an interface to create more tables on the fly and edit the table fields at will.
    <br/>
    The purpose of this demonstration is to show that IndexedDB can be tapered down to represent any 'tame' store as a table.
  </p>
</div>
<div>
  <div class="labelField">
    <label for="database">Database: </label><input id="database" name="database" type="text" disabled="disabled" /><!-- <button id="databaseChange">Change</button> -->
  </div>
  &nbsp;&nbsp;&nbsp;&nbsp;
  <div class="labelField">
    <label for="tableSelect">Table: </label><select id="tableSelect" name="tableSelect"></select>
  </div>
</div>
<div id="tableContainer">
  <table id="table">
    <tr id="tableHeader">
      <th></th>
    </tr>
  </table>
</div>
<div id="jsonView">
</div>
<div>
  <h2>Console:</h2>
  <div id="console">
  </div>
</div>
<!--
  Neat but not sure if I will do:
    - Add ability for formula row
      -> Add this.row, this.col, this.get(row, col), this.getRel(relRow, relCol)
    - Add multi-row editing
    - Column/row resizing


    - Double click for enable/disable cell
    - JSON view

  TODO:
    - Add/delete row/col buttons [use transactions here]
    - Update table select box
    - Implement table select box
    - Implement create table button
    - Implement db selection
    - onrowadd
    - onrowdelete
    - onrowchange
    - Same methods for columns
    - oncelldisable
    - oncellenable
    - Robust test object edit/save
    - Down coerce JSON to string and try to upconvert JSON to object
-->
<script>
(function(window, document){
  // Fallback and globalize indexedDB variables
  window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB;
  window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction;
  window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;
  window.IDBCursor = window.IDBCursor || window.webkitIDBCursor;

  // Localize indexedDB
  var indexedDB = window.indexedDB,
      _consoleDiv = document.getElementById('console'),
      _console = {
        'error': function (msg) {
          this.log('<span class="error">' + msg + '</span>');
        },
        'log': function (msg) {
          _consoleDiv.innerHTML = '<div>[' + (new Date().toLocaleString()) + '] ' + msg + '</div>' + _consoleDiv.innerHTML;
        }
      };

  // If indexedDB cannot be found
  if (indexedDB === undefined) {
    // Let the user know a different browser should be used
    _console.error('Your browser does not support IndexedDB');
    return;
  }

  // Attempt to open our db
  var databaseField = document.getElementById('database'),
      databaseName = 'devDerby',
      derbyDbRequest = indexedDB.open(databaseName, 'MDN Dev Derby DB');

  databaseField.value = databaseName;

  // If we are denied
  derbyDbRequest.onerror = function () {
    // Let the user know we need access to continue
    _console.error('You must allow access to your IndexedDB for this webpage');
    return;
  };

  // If we are allowed in
  derbyDbRequest.onsuccess = function (e) {
    // Grab the db
    var derbyDb = e.target.result,
    // Objectify the table
        table = (function(document){
          function Indexer() {
            this.arr = [];
            this.map = {};
            this.counter = 0;
          }

          Indexer.prototype = {
            'push': function (key) {
              var map = this.map;
              if (map.hasOwnProperty(key)) {
                throw new Error('Indexer key is already defined: ' + key);
              }
              // Save key to counter value (preserves order even through decrement)
              map[key] = this.counter;

              // Add item to array
              this.arr.push(key);

              // Increment counter
              this.counter += 1;
            },
            'delete': function (key) {
              // Delete from map
              delete map[key];

              // Find and remove item from array
              var arr = this.arr,
                  arrIndex = arr.indexOf(key);
              arr.splice(arrIndex, 1);
            },
            'count': function () {
              return this.arr.length;
            }
          };

          var retObj = {},
          // Localize and privitize the table
              _table = document.getElementById('table'),
              _tableParent = _table.parentNode,
              _tableHeader = document.getElementById('tableHeader'),

          // Private vars
              _rows = [],
              _rowIndexer = new Indexer(),
              _colIndexer = new Indexer();
              /*              _colCount = 0,
              _colIndexMap = {}; */

          // Private helper fns
          function _actOnEachRow(fn) {
            var row,
                i;
            for (i = _rows.length; i--; ) {
              row = _rows[i];
              fn(i, row);
            }
          }

          function _createCell(rowKey, colKey, val) {
            // Visciously require a row and column number during construction
            if (rowKey === undefined || colKey === undefined) {
              throw new Error('Row/col not specified for cell constructor');
            }

            var td = document.createElement('td'),
                input = document.createElement('input'),
                _lastVal = val || '',
                checkTimeout;

            // Set up input type and value
            input.setAttribute('type', 'text');
            input.value = _lastVal;

            // If the the value is undefined, disable the cell
            if (val === undefined) {
              td.className = 'disabled';
            }

            // Watch content for changes
            function checkChange() {
              var val = input.value;
              if (_lastVal !== val) {
                _lastVal = val;
                retObj.oncellupdate(rowKey, colKey, val);
              }
            }

            function checkChangeLoop() {
              // Memoize timeout for onblur
              checkTimeout = setTimeout(function () {
                // Check if anything has changed
                checkChange();

                // Loop on self
                checkChangeLoop();
              }, 100);
            }

            input.onfocus = checkChangeLoop;

            input.onblur = function () {
              // Stop any further checks
              clearTimeout(checkTimeout);

              // Perform one final check
              checkChange();
            };

            // Append the input to the td
            td.appendChild(input);

            // Return generated cell
            return td;
          }

          retObj = {
            'removeFromFlow': function () {
              _tableParent.removeChild(_table);
              _table.setAttribute('style', 'display: none');
            },
            'returnToFlow': function () {
              _table.setAttribute('style', '');
              _tableParent.appendChild(_table);
            },
            'flushTable': function () {
              // TODO: Replace with delRow and delCol
              // Clean out table
              _actOnEachRow(function (i, row) {
                _table.removeChild(row);
              });

              // Flush any memory leaks too
              _rows = [];
            },
            'addRow': function (rowKey, row) {
              var tr = document.createElement('tr'),
                  th = document.createElement('th'),
                  colKeys = _colIndexer.map,
                  key;

              // Generate th for the row
              th.innerHTML = rowKey;
              tr.appendChild(th);

              // Iterate the keys and generate any new columns
              for (key in row) {
                if (row.hasOwnProperty(key)) {
                  if (!colKeys.hasOwnProperty(key)) {
                    this.addCol(key);
                  }
                }
              }

              // Iterate the table's columns
              var colNameArr = _colIndexer.arr,
                  colName,
                  i = _rowIndexer.count(),
                  j = 0,
                  len = colNameArr.length,
                  td;

              for ( ; j < len; j++ ) {
                // Localize column name
                colName = colNameArr[j];

                // Populate the cell
                td = _createCell(rowKey, colName, row[colName]);

                 // Append the cell to the row
                tr.appendChild(td);
              }

              // TODO: Double click disable/enable cell

              // Append row to table
              _table.appendChild(tr);

              // Increment rowCount and save to rows
              _rows.push(tr);
              _rowIndexer.push(rowKey);
            },
            'addCol': function (colKey) {
              // Add th
              var th = document.createElement('th');
              th.innerHTML = colKey;
              _tableHeader.appendChild(th);

              // Add new cell for each row
             var rowKeys = _rowIndexer.arr;
              _actOnEachRow(function (i, tr) {
                var rowKey = rowKeys[i];
                tr.appendChild( _createCell(rowKey, colKey) );
              });

              // Index latest key
              _colIndexer.push(colKey);
            },
            'populate': function (rows) {
              var key;

              // Hide the table and remove it from the DOM (reduce repaints/reflows)
              this.removeFromFlow();

              // Clean out the table
              this.flushTable();

              // Iterate object and add rows
              for (key in rows) {
                if (rows.hasOwnProperty(key)) {
                  this.addRow(key, rows[key]);
                }
              }

              // Unhide the table
              this.returnToFlow();
            },
            'oncellupdate': function(){}
          };

          return retObj;
        }(document));

    // Set up error handling
    function onerror(f) {
      _console.error('An error has occurred that I have not accounted for. Please panic or refresh the page');
      console && console.error && console.error(f);
      return;
    }
    derbyDb.onerror = onerror;

    // And disco.

    // Set up continue fn
    function continueFn() {
      var objectStoreNames = derbyDb.objectStoreNames,
          objectStoreName,
          rows = {},
          transaction,
          objectStore,
          cursor;

      if (objectStoreNames.length < 1) {
        onerror('No object stores exist when one should');
      }

      // Choose the first alphabetical table from objectStoreNames
      objectStoreName = objectStoreNames[0];

      // Then begin to collect rows
      transaction = derbyDb.transaction(objectStoreName);
      objectStore = transaction.objectStore(objectStoreName);
      cursorRequest = objectStore.openCursor();

      // Handle errors and successes
      cursorRequest.onerror = onerror;
      cursorRequest.onsuccess = function () {
        var cursor = cursorRequest.result,
            getRequest;

        // If the cursor is pointing to something
        if (cursor !== undefined) {
          // Retrieve it
          getRequest = objectStore.get(cursor.key);
          getRequest.onerror = onerror;
          getRequest.onsuccess = function () {
            // And add it to a new row
            rows[cursor.key] = getRequest.result;

            // Continue to next row
            cursor.continue();
          };
        } else {
        // Otherwise, populate the table
          table.populate(rows);

          // And update to the proper oncellupdate
          table.oncellupdate = function (rowIndex, colIndex, value) {
            // Update our local copy of row
            var row = rows[rowIndex],
                transaction,
                objectStore,
                request;
            row[colIndex] = value;

            // Try to save to db
            transaction = derbyDb.transaction(objectStoreName, IDBTransaction.READ_WRITE);
            objectStore = transaction.objectStore(objectStoreName);
            request = objectStore.put(row, rowIndex);
            request.onerror = onerror;
            request.onsuccess = function () {
              _console.log('Row ' + rowIndex + ', Column ' + colIndex + ' successfully updated.');
            };
          };
        }
      }
    }

    // Helper function for creating sheets
    function createSheet(name, callback) {
      var req = derbyDb.setVersion('0.1');
      req.onerror = onerror;
      req.onsuccess = function () {
        var newStore = derbyDb.createObjectStore(name),
            // ''     'Hello' 'and'       'welcome'       'to'
            // 'my'   'MDN'   'Dev Derby' 'demonstration' -
            // 'of'   -       -           -               'IndexedDB'
            rowObjs = {
              'my': {
                'Hello': 'MDN',
                'and': 'Dev Derby',
                'welcome': 'demonstration'
              },
              'of': {
                'to': 'IndexedDB'
              }
            },
            key,
            rowKeyArr = [],
            i = 0,
            len;

        // Populate rowArr
        for (key in rowObjs) {
          if (rowObjs.hasOwnProperty(key)) {
            rowKeyArr.push(key);
          }
        }
        len = rowKeyArr.length;

        function addNextRow() {
          // If we have added all the rows, call our callback
          if (i >= len) {
            if (callback) {
              callback();
            }
            return;
          }

          // Add row to store
          var rowKey = rowKeyArr[i],
              putRequest = newStore.put(rowObjs[rowKey], rowKey);
          putRequest.onerror = onerror;
          putRequest.onsuccess = function () {
            // Increment and continue looping
            i += 1;
            addNextRow();
          };
        }

        // Begin adding rows
        addNextRow();
      }
    }

    // If no tables are found
    if (derbyDb.objectStoreNames.length === 0) {
      // Populate our example table
      createSheet('Example Table', continueFn);
    } else {
    // Otherwise, invoke continueFn
      continueFn();
    }
  };
}(this, document));
</script>
</body>
</html>
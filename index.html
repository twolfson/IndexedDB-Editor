<!doctype>
<html>
<head>
	<title>MDN Derby - December 2011</title>
	<style>
    /* Visual fixes (poor man's reset/normalize.css) */
		* {
			margin: 0;
			padding: 0;
		}

    body {
      background: linen;
    }

    body > div {
      margin-bottom: 1em;
    }

    .labelField {
      display: inline;
    }

    .error {
      color: red;
      font-weight: bold;
    }

    #table {
      border-collapse: collapse;
    }

    #table td {
      border: 2px solid #CCC;
      padding: 2px;
    }

    #table input {
      border: 0;
    }

    #console {
      background: #CCC;
      height: 20em;
      overflow: auto;
    }
	</style>
</head>
<body>
<h1>IndexedDB Demonstration</h1>
<div>
  <p>
    In this demonstration, a sample database has been set up, via the IndexedDB API, as well as an example table. There is an interface to create more tables on the fly and edit the table fields at will.
    <br/>
    The purpose of this demonstration is to show that IndexedDB can be tapered down to represent any 'tame' store as a table.
    <!-- TODO: Hide everything else until db connects -->
  </p>
</div>
<div>
  <div class="labelField">
    <label for="database">Database: </label><input id="database" name="database" type="text" disabled="disabled" /><!-- <button id="databaseChange">Change</button> -->
  </div>
  &nbsp;&nbsp;&nbsp;&nbsp;
  <div class="labelField">
    <label for="tableSelect">Table: </label><select id="tableSelect" name="tableSelect"></select><!-- TODO: Implement me -->
  </div>
</div>
<div id="tableContainer">
  <table id="table"></table>
</div>
<div>
  <h2>Console:</h2>
  <div id="console">
  </div>
</div>
<!--
  Neat but not sure if I will do:
    - Add ability for formula row
      -> Add this.row, this.col, this.get(row, col), this.getRel(relRow, relCol)
    - Add multi-row editing
    - Export functionality
    - Column/row resizing
    - Swap from array-like table to object table [swapping out numeric naming schema for a mixed schema]

  TODO:
    - Add/delete row/col buttons [use transactions here]
    - Header rows/cols
-->
<script>
(function(window, document){
  // Fallback and globalize indexedDB
  var indexedDB = window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB,
      _consoleDiv = document.getElementById('console'),
      _console = {
        'error': function (msg) {
          this.log('<span class="error">' + msg + '</span>');
        },
        'log': function (msg) {
          _consoleDiv.innerHTML = '<div>[' + (new Date().toLocaleString()) + '] ' + msg + '</div>' + _consoleDiv.innerHTML;
        }
      };

  // If indexedDB cannot be found
  if (indexedDB === undefined) {
    // Let the user know a different browser should be used
    _console.error('Your browser does not support IndexedDB');
    return;
  }

  // Attempt to open our db
  var databaseField = document.getElementById('database'),
      databaseName = 'devDerby',
      derbyDbRequest = indexedDB.open(databaseName, 'MDN Dev Derby DB');

  databaseField.value = databaseName;

  // If we are denied
  derbyDbRequest.onerror = function () {
    // Let the user know we need access to continue
    _console.error('You must allow access to your IndexedDB for this webpage');
    return;
  };

  // If we are allowed in
  derbyDbRequest.onsuccess = function (e) {
    // Grab the db
    var derbyDb = e.target.result,
    // Objectify the table
        table = (function(document){
          var retObj = {},
          // Localize and privitize the table
              _table = document.getElementById('table'),
              _tableParent = _table.parentNode,

          // Private vars
              _rowCount = 0,
              _colCount = 0;

          // Private helper fns
          function _actOnEachRow(fn) {
            var rows = _table.childNodes || [],
                row,
                i;
            for (i = rows.length; i--; ) {
              row = rows[i];
              fn(i, row);
            }
          }

          function _getCell(row, col, val) {
            // Visciously require a row and column number during construction
            if (row === undefined || col === undefined) {
              throw Error('Row/col not specified for cell constructor');
            }

            var td = document.createElement('td'),
                input = document.createElement('input'),
                _lastVal = val || '',
                checkTimeout;

            // Set up input type and value
            input.setAttribute('type', 'text');
            input.value = _lastVal;

            // Watch content for changes
            function checkChange() {
              var val = input.value;
              if (_lastVal !== val) {
                _lastVal = val;
                retObj.oncellupdate(row, col, val);
              }
            }

            function checkChangeLoop() {
              // Memoize timeout for onblur
              checkTimeout = setTimeout(function () {
                // Check if anything has changed
                checkChange();

                // Loop on self
                checkChangeLoop();
              }, 100);
            }

            input.onfocus = checkChangeLoop;

            input.onblur = function () {
              // Stop any further checks
              clearTimeout(checkTimeout);

              // Perform one final check
              checkChange();
            };

            // Append the input to the td
            td.appendChild(input);

            // Return generated cell
            return td;
          }

          retObj = {
            'removeFromFlow': function () {
              _tableParent.removeChild(_table);
              _table.setAttribute('style', 'display: none');
            },
            'returnToFlow': function () {
              _table.setAttribute('style', '');
              _tableParent.appendChild(_table);
            },
            'flushTable': function () {
              _actOnEachRow(function (i, row) {
                _table.removeChild(row);
              });
            },
            'addRow': function (row) {
              row = row || [];
              var tr = document.createElement('tr'),
                  cellValue,
                  i = 0,
                  len = row.length,
                  colDiff = len - _colCount;

              // If there is a different number of columns in this row than there are in the table
              if (colDiff !== 0) {
                // Then, if there are more columns
                if (colDiff > 0) {
                  // Add columns to previous rows
                  _actOnEachRow(function (i, row) {
                    var j = 0,
                        len = colDiff,
                        td;
                    for ( ; j < len; j++ ) {
                      row.appendChild( _getCell(i, j) );
                    }
                  });

                  // Save new colCount
                  _colCount = len;
                } else {
                // Otherwise, add columns to this row
                  // The only smart time to use new Array
                  row = row.concat(new Array(colDiff));

                  // Save new row length
                  len = _colCount;
                }
              }

              // Add a new row and its respective cells
              for ( ; i < len; i++ ) {
                cellValue = row[i];
                tr.appendChild( _getCell(_rowCount, i, cellValue) );
              }

              // Append row to table
              _table.appendChild(tr);

              // Increment rowCount
              _rowCount += 1;
            },
            // TODO: addCol
            'populate': function (rows) {
              var row,
                  i,
                  len;

              // Hide the table and remove it from the DOM (reduce repaints/reflows)
              this.removeFromFlow();

              // Clean out the table
              this.flushTable();

              // Fallback rows
              rows = rows || [];
              for (i = 0, len = rows.length; i < len; i++ ) {
                row = rows[i];
                this.addRow(row);
              }

              // Unhide the table
              this.returnToFlow();
            },
            'oncellupdate': function(){}
          };

          return retObj;
        }(document));

    // Set up error handling
    function onerror(f) {
      _console.error('An error has occurred that I have not accounted for. Please panic or refresh the page');
      console && console.error && console.error(f);
      return;
    }
    derbyDb.onerror = onerror;

    // And disco.

    // Set up continue fn
    function continueFn() {
      var objectStoreNames = derbyDb.objectStoreNames,
          objectStoreName,
          rows = [],
          transaction,
          objectStore,
          cursor;

      if (objectStoreNames.length < 1) {
        onerror('No object stores exist when one should');
      }

      // Choose the first alphabetical table from objectStoreNames
      objectStoreName = objectStoreNames[0];

      // Then begin to collect rows
      transaction = derbyDb.transaction(objectStoreName);
      objectStore = transaction.objectStore(objectStoreName);
      cursorRequest = objectStore.openCursor();

      // Handle errors and successes
      cursorRequest.onerror = onerror;
      cursorRequest.onsuccess = function () {
        var cursor = cursorRequest.result,
            getRequest;

        // If the cursor is pointing to something
        if (cursor !== undefined) {
          // Retrieve it
          getRequest = objectStore.get(cursor.key);
          getRequest.onerror = onerror;
          getRequest.onsuccess = function () {
            // And add it to a new row
            // TODO: Actually use keys (cursor.key) for rows
            rows.push( getRequest.result );

            // Continue to next row
            cursor.continue();
          };
        } else {
        // Otherwise, populate the table
          table.populate(rows);
          
          // And update to the proper oncellupdate
          table.oncellupdate = function (rowIndex, colIndex, value) {
            // Update our local copy of row
            var row = rows[rowIndex],
                transaction,
                objectStore,
                request;
            row[colIndex] = value;
            
            // Try to save to db
            transaction = derbyDb.transaction(objectStoreName, IDBTransaction.READ_WRITE);
            objectStore = transaction.objectStore(objectStoreName);
            request = objectStore.put(row, rowIndex);
            request.onerror = onerror;
            request.onsuccess = function () {
              _console.log('Row ' + rowIndex + ', Column ' + colIndex + ' successfully updated.');
            };
          };
        }
      }
    }

    // Helper function for creating sheets
    function createSheet(name, callback) {
      var req = derbyDb.setVersion('0.1');
      req.onerror = onerror;
      req.onsuccess = function () {
        var newStore = derbyDb.createObjectStore(name),
            rows = [
              ['Hello', 'and', 'welcome', 'to'],
              ['my', 'IndexedDB', 'Dev Derby', 'Entry']
            ],
            i = 0,
            len = rows.length;

        function addNextRow() {
          // If we have added all the rows, call our callback
          if (i >= len) {
            if (callback) {
              callback();
            }
            return;
          }

          // Add row to store
          var putRequest = newStore.put(rows[i], i);
          putRequest.onerror = onerror;
          putRequest.onsuccess = function () {
            // Increment and continue looping
            i += 1;
            addNextRow();
          };
        }

        // Begin adding rows
        addNextRow();
      }

      // TODO: Update table select box
      // TODO: Implement table select box
    }

    // If no tables are found
    if (derbyDb.objectStoreNames.length === 0) {
      // Populate our example table
      createSheet('Example Table', continueFn);
    } else {
    // Otherwise, invoke continueFn
      continueFn();
    }
  };
}(this, document));
</script>
</body>
</html>